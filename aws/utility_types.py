import hashlib
import base64
import secrets
import time
import hmac

class PasswordUtility(object):
    def __init__(self):
        pass

    def __get_salt_bytes(self, length: int = 32) -> bytes:
        """
        Args:
            length (int, 32):
                Length of bytes to return
        Returns:
            bytes:
                A list of randomly generated bytes of stated length
        """
        return secrets.token_bytes(length)

    def hash_password(self, password_text: str, salt_bytes: bytes = None) -> tuple[str, str]:
        """
        Hash a password given text and salt using SHA256
        If salt is not provide, a randomly generated salt will be used.

        Args:
            password_text (str):
                Plain text to be hashed.
            salt_bytes (bytes, optional):
                List of bytes use to salt password.
        Returns:
            (hex_digest, salt_b64):
                hex_digest (str):
                    Hash result in hexadecimal
                salt_b64 (str):
                    A base64 representation of salt used in hashing
        """
        if salt_bytes is None:
            salt_bytes = self.__get_salt_bytes()
        password_bytes = password_text.encode('utf-8')
        combined_bytes = salt_bytes + password_bytes

        sha256 = hashlib.sha256()
        sha256.update(combined_bytes)
        return sha256.hexdigest(), base64.b64encode(salt_bytes).decode()

    def decode_base64_to_bytes(self, base64_string: str) -> bytes:
        """Decodes a base64 string to a list of bytes
        Args:
            base64_string (str):
                Base64 string to be decoded into byte list
        Returns:
            bytes:
                List of bytes representing the base64 form of the argument

        """
        return base64.b64decode(base64_string)

    def __str__(self):
        """
        Returns:
            str:
                Class name of utility object
        """
        return self.__class__.__name__

    def __repr__(self):
        """
        Returns:
            str:
                Class name of utility object
        """
        return self.__class__.__name__

class TokenUtility(object):
    def __init__(self, secret_key:str):
        # Secret key used for signing the token (keep this secure and private)
        # SECRET_KEY = b'super_secret_key'
        self.SECRET_KEY = secret_key.encode('utf8')

    def generate_token(self, expiry_in_seconds:int) -> str:
        """
        Generates a token with an expiry timestamp that is cryptographically signed.

        Args:
            expiry_in_seconds (int): Number of seconds until the token expires.

        Returns:
            str: A secure, tamper-proof token.
        """
        # Calculate the expiry timestamp
        expiry_timestamp = int(time.time()) + expiry_in_seconds

        # Create the message to be signed (expiry timestamp as a string)
        message = str(expiry_timestamp).encode()

        # Generate the HMAC signature using the secret key and SHA256
        signature = hmac.new(self.SECRET_KEY, message, hashlib.sha256).digest()

        # Encode the expiry timestamp and signature into a single token
        token = base64.urlsafe_b64encode(message + signature).decode()

        return token

    def verify_token(self, token:str):
        """
        Verifies the token's validity, checks if it has expired, and detects tampering.

        Args:
            token (str): The token to verify.

        Returns:
            bool: True if the token is valid and not expired, False otherwise.
        """
        try:
            # Decode the token from Base64
            decoded_data = base64.urlsafe_b64decode(token.encode())

            # Split the decoded data into the expiry timestamp and the signature
            expiry_timestamp = int(decoded_data[:-32].decode())  # First part is the timestamp
            signature = decoded_data[-32:]  # Last 32 bytes are the HMAC signature

            # Recreate the signature using the expiry timestamp and the secret key
            expected_signature = hmac.new(self.SECRET_KEY, str(expiry_timestamp).encode(), hashlib.sha256).digest()

            # Check if the signature matches (detect tampering)
            if not hmac.compare_digest(signature, expected_signature):
                print("Token has been tampered with!")
                return False

            # Check if the token has expired
            if time.time() > expiry_timestamp:
                print("Token has expired!")
                return False

            # Token is valid
            return True

        except Exception as e:
            # Handle decoding errors or other issues
            print(f"Invalid token: {e}")
            return False


if __name__ == "__main__":
    cls = PasswordUtility()
    print(cls)

    # Generate a token that expires in 60 seconds
    token_utility = TokenUtility('some_secret_key')
    token = token_utility.generate_token(5)
    print(f"Generated Token: {token}")

    # Verify the token
    is_valid = token_utility.verify_token(token)
    print(f"Is token valid? {is_valid}")

    time.sleep(5)
    is_valid = token_utility.verify_token(token)
    print(f"Is token valid after 5 seconds? {is_valid}")

