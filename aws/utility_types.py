import hashlib
import base64
import secrets
import time
import hmac
import os

class PasswordUtility(object):
    def __init__(self):
        pass

    def __get_salt_bytes(self, length: int = 32) -> bytes:
        """
        Args:
            length (int, 32):
                Length of bytes to return
        Returns:
            bytes:
                A list of randomly generated bytes of stated length
        """
        return secrets.token_bytes(length)

    def hash_password(self, password_text: str, salt_bytes: bytes = None) -> tuple[str, str]:
        """
        Hash a password given text and salt using SHA256
        If salt is not provide, a randomly generated salt will be used.

        Args:
            password_text (str):
                Plain text to be hashed.
            salt_bytes (bytes, optional):
                List of bytes use to salt password.
        Returns:
            (hex_digest, salt_b64):
                hex_digest (str):
                    Hash result in hexadecimal
                salt_b64 (str):
                    A base64 representation of salt used in hashing
        """
        if salt_bytes is None:
            salt_bytes = self.__get_salt_bytes()
        password_bytes = password_text.encode('utf-8')
        combined_bytes = salt_bytes + password_bytes

        sha256 = hashlib.sha256()
        sha256.update(combined_bytes)
        return sha256.hexdigest(), base64.b64encode(salt_bytes).decode()

    def decode_base64_to_bytes(self, base64_string: str) -> bytes:
        """Decodes a base64 string to a list of bytes
        Args:
            base64_string (str):
                Base64 string to be decoded into byte list
        Returns:
            bytes:
                List of bytes representing the base64 form of the argument

        """
        return base64.b64decode(base64_string)

    def __str__(self):
        """
        Returns:
            str:
                Class name of utility object
        """
        return self.__class__.__name__

    def __repr__(self):
        """
        Returns:
            str:
                Class name of utility object
        """
        return self.__class__.__name__

class TokenUtility(object):
    def __init__(self, secret_key:str):
        # Secret key used for signing the token (keep this secure and private)
        # SECRET_KEY = b'super_secret_key'
        self.SECRET_KEY = secret_key.encode('utf8')

    def generate_token(self, expiry_in_seconds:int, content: str) -> str:
        """
        Generates a token with an expiry timestamp that is cryptographically signed.

        Args:
            expiry_in_seconds (int): Number of seconds until the token expires.

        Returns:
            str: A secure, tamper-proof token.
        """
        # Calculate the expiry timestamp
        expiry_timestamp = int(time.time()) + expiry_in_seconds
        payload = f"{expiry_timestamp}|{content}".encode('utf-8')

        # Generate the HMAC signature using the secret key and SHA256
        signature = hmac.new(self.SECRET_KEY, payload, hashlib.sha256).digest()

        # Encode the expiry timestamp and signature into a single token
        token = base64.urlsafe_b64encode(payload + signature).decode()

        return token

    def verify_token(self, token:str):
        """
        Verifies the token's validity, checks if it has expired, and detects tampering.

        Args:
            token (str): The token to verify.

        Returns:
            bool: True if the token is valid and not expired, False otherwise.
        """
        try:
            # Decode the token from Base64
            decoded_data = base64.urlsafe_b64decode(token.encode())

            # Split the decoded data into the expiry timestamp and the signature
            payload = decoded_data[:-32]    # Anything before last 32 bytes is payload
            signature = decoded_data[-32:]  # Last 32 bytes are the HMAC signature

            # Recreate the signature using the expiry timestamp and the secret key
            expected_signature = hmac.new(self.SECRET_KEY, payload, hashlib.sha256).digest()

            # Check if the signature matches (detect tampering)
            if not hmac.compare_digest(signature, expected_signature):
                print("Token has been tampered with!")
                return False

            payload_str = payload.decode('utf-8')
            expiry_str, message = payload_str.split('|', 1)
            expiry_timestamp = int(expiry_str)

            # Check if the token has expired
            if time.time() > expiry_timestamp:
                print("Token has expired!")
                return False

            # Token is valid
            return True

        except Exception as e:
            # Handle decoding errors or other issues
            print(f"Invalid token: {e}")
            return False

class FileUtility(object):
    @staticmethod
    def normalize_path(directory_path, file_name = None):
        """
        Normalize file paths such that they always look like:
        C:/dir1/dir2/.../file
        """
        if file_name is None:
            target_path = directory_path
        else:
            target_path = os.path.join(directory_path, file_name)
        file_path = os.path.normpath(target_path)
        file_path.replace('\\', '/')
        return file_path

    @staticmethod
    def get_file_path_parts(file_path):
        """
        Note: A file_path like '.coverage' returns '.coverage' as file_name and '' as file_extension
        """
        split_ext = os.path.splitext(file_path)
        file_name = split_ext[0]
        file_extension = split_ext[1].lower()
        return (file_name, file_extension)



if __name__ == "__main__":
    cls = PasswordUtility()
    print(cls)

    # Generate a token that expires in 60 seconds
    token_utility = TokenUtility('some_secret_key')
    token = token_utility.generate_token(5, 'test content')
    print(f"Generated Token: {token}")

    # Verify the token
    is_valid = token_utility.verify_token(token)
    print(f"Is token valid? {is_valid}")

    time.sleep(5)
    is_valid = token_utility.verify_token(token)
    print(f"Is token valid after 5 seconds? {is_valid}")

